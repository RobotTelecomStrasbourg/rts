/*
   Code séance d'initiation du Club Robot
   Parcours d'obstacles

	Conseil :
	1) Suivi de ligne
	2) Odom 1D

	Faire des tests en lançant
 
	NOTICE : Demarrer le robot sur du blanc pour la calibration des capteurs de
		luminosité pour le suivi de ligne.

	author : Kilian Hett, Valentin Niewada
*/

#define MAXPOWER -70
#define MINPOWER -30

#define TEMPMIN 150
#define TEMPEVIT 1000

#define True 0==0
#define Flase !True

#define SENSORRIGHT S3
#define SENSORLEFT S4

typedef t_semaphore int;


/*
	Definition des variables globales
*/
float captR_ref=0;
float captL_ref=0;
float captR_value=0;
float captL_value=0;

// Puissance moteur
int powerRight=0;
int powerLeft=0;

// Odometrie
int X_parcouru=0;
int X_offset=0;

// Semaphore
t_semaphore semaphore=0;

/*
	Thread 1 :  Redressement à droite
 */
task sensorRight()
{
	int accumulator=0;
	captR_ref= SensorValue(SENSORRIGHT)-10;
	while(True)
	{
		captR_value = SensorValue(SENSORRIGHT);
		if (captR_ref > captR_value)
		{
			powerRight = MAXPOWER;
		}
		else
		{
			powerRight = MINPOWER;
		}
		Wait(TEMPMIN);
	}
}

/* 
   Thread 2 : Redressement à gauche
 */
task sensorLeft()
{
	int accumulatori=0;

	captL_ref= SensorValue(SENSORLEFT)-10;
	while(True)
	{
		captL_value= SensorValue(SENSORLEFT);

		if (captL_ref-10>captL_value)
		{
			powerLeft = MAXPOWER;
		}
		else
		{
			powerLeft = MINPOWER;
		}
		Wait(TEMPMIN);
	}
}

/*
	Thread 3 : Odometrie 1D 
 */
task odometrie1D()
{	
	// Calcul de la distance parcouru
	X_parcouru = ((-MotorRotationCount(MOT_DROITE)/360.0)+
		(-MotorRotationCount(MOT_GAUCHE)/360.0))/2;
	X = X_parcouru - X_offset;
}

/*
	Thread 4 : Detection d'obstacle	
*/
task evitemment()
{
	int distance=/* 20 */;
	int pseudo_sema=0;
	while (true)
	{
		if (detection())
		{
			pseudo_sema=1;
		}
		else 
		{
			pseudo_sema=0;
		}
		semaphore=semaphore+pseudo_sema;
		Wait(TMPEVIT);
	}
}



void suivreLigne(int mm)
{
	X_offset=X_parcouru;
	while (X<mm)
	{
		if (semaphore==0)
		{
			OnFwd(OUT_B,powerRight);
			OnFwd(OUT_A,powerLeft);
		}
	}
}


void pivotement()
{
	SEMAPHORE=/* true */;
	if(rouge== 1)
	{
		RotateMotorEx(MOTEURS, 80, 11,100, true,true);
	}
	else
	{
		RotateMotorEx(OUT_AB, 80, 11, -100, true,true);
	}
	SEMAPHORE=/* false */;
}


/*
   Fonction principale "main"
 */
task main()
{
	SetSensorLight(SENSORRIGHT);
	SetSensorLight(SENSORLEFT);

	start sensorRight;
	start sensorLeft;

	while(1==1)
	{
		// TODO Implémenter le code pour faire les différentes
		// actions attendu
	}
}
